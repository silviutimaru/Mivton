const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const session = require('express-session');
const pgSession = require('connect-pg-simple')(session);
const cors = require('cors');
const helmet = require('helmet');
const path = require('path');
require('dotenv').config();

// Import custom modules
const { initializeDatabase, getDb } = require('./database/connection');
const { testEmailConnection } = require('./utils/email');
const authRoutes = require('./routes/auth');
const { addUserToLocals } = require('./middleware/auth');
const { waitlistUtils } = require('./utils/waitlist');

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
  cors: {
    origin: process.env.FRONTEND_URL || "https://mivton.com",
    methods: ["GET", "POST"],
    credentials: true
  },
  // Railway WebSocket configuration
  transports: ['polling', 'websocket'],
  allowEIO3: true,
  pingTimeout: 60000,
  pingInterval: 25000
});

const PORT = process.env.PORT || 3000;
const HOST = process.env.NODE_ENV === 'production' ? '0.0.0.0' : 'localhost';

// ===== MIDDLEWARE SETUP =====

// Trust proxy for Railway deployment (more secure)
app.set('trust proxy', 1);

// Security middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-hashes'"],
      scriptSrcAttr: ["'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "ws:", "wss:"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'", "https://ssl.gstatic.com", "data:", "blob:"],
      frameSrc: ["'none'"],
    },
  },
  crossOriginEmbedderPolicy: false
}));

// CORS middleware
app.use(cors({
  origin: process.env.FRONTEND_URL || "https://mivton.com",
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'Cookie']
}));

// Body parsing middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Session middleware
// Session configuration - use same logic as database connection
const isLocalDev = !process.env.DATABASE_URL && 
                   !process.env.FORCE_POSTGRESQL && 
                   process.env.NODE_ENV !== 'production' && 
                   (process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test');

console.log('üîç Session configuration decision:', {
    DATABASE_URL: !!process.env.DATABASE_URL,
    FORCE_POSTGRESQL: !!process.env.FORCE_POSTGRESQL,
    NODE_ENV: process.env.NODE_ENV,
    isLocalDev
});

// Use memory store for both local and production to avoid database session store issues
console.log('üîß Using memory session store for all environments');
app.use(session({
  store: new (require('express-session').MemoryStore)(),
  secret: process.env.JWT_SECRET || 'mivton-super-secret-jwt-key-2025-production',
  resave: false,
  saveUninitialized: false,
  rolling: true,
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000, // 24 hours
    sameSite: process.env.NODE_ENV === 'production' ? 'none' : 'lax'
  },
  name: 'mivton.sid'
}));

// Add user to locals middleware
app.use(addUserToLocals);

// Serve default avatar if missing (before static files)
app.get('/images/default-avatar.*', (req, res) => {
  const svgAvatar = `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="bg" x1="0%" y1="0%" x2="100%" y2="100%">
        <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
        <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
      </linearGradient>
    </defs>
    <circle cx="50" cy="50" r="50" fill="url(#bg)"/>
    <circle cx="50" cy="35" r="15" fill="#ffffff"/>
    <ellipse cx="50" cy="75" rx="20" ry="15" fill="#ffffff"/>
  </svg>`;
  
  res.setHeader('Content-Type', 'image/svg+xml');
  res.setHeader('Cache-Control', 'public, max-age=31536000');
  res.send(svgAvatar);
});

// Static files middleware
app.use(express.static(path.join(__dirname, 'public')));

// Request logging middleware
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);
  next();
});

// ===== ROUTES =====

// Health check endpoint
app.get('/health', async (req, res) => {
  try {
    const db = getDb();
    await db.query('SELECT 1');
    
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      services: {
        database: 'connected',
        server: 'running',
        authentication: 'active'
      }
    });
  } catch (error) {
    console.error('Health check failed:', error);
    res.status(500).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error.message
    });
  }
});


// API status endpoint
app.get('/api/status', async (req, res) => {
  try {
    const db = getDb();
    
    // Test database connection
    const dbResult = await db.query('SELECT NOW() as current_time');
    
    // Get basic stats
    const userCount = await db.query('SELECT COUNT(*) FROM users');
    const waitlistCount = await db.query('SELECT COUNT(*) FROM waitlist');
    
    res.json({
      status: 'operational',
      timestamp: new Date().toISOString(),
      database: {
        connected: true,
        timestamp: dbResult.rows[0].current_time
      },
      stats: {
        totalUsers: parseInt(userCount.rows[0].count),
        waitlistUsers: parseInt(waitlistCount.rows[0].count)
      },
      version: '1.3.3',
      features: {
        authentication: true,
        registration: true,
        email: true,
        sessions: true
      }
    });
  } catch (error) {
    console.error('Status check failed:', error);
    res.status(500).json({
      status: 'error',
      timestamp: new Date().toISOString(),
      error: error.message
    });
  }
});

// Waitlist endpoints (from Phase 1.2)
app.post('/api/waitlist', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return res.status(400).json({
        success: false,
        message: 'Valid email is required'
      });
    }

    // Get request metadata
    const emailData = {
      email: email.toLowerCase().trim(),
      referrer: req.get('Referrer') || null,
      user_agent: req.get('User-Agent') || null,
      ip_address: req.ip || req.connection.remoteAddress || null
    };

    // Store in database
    const result = await waitlistUtils.addEmail(emailData);
    
    if (result.success) {
      console.log('‚úÖ Waitlist signup stored:', email);
      res.json({
        success: true,
        message: 'Thanks for joining the waitlist! We\'ll notify you when Mivton launches.'
      });
    } else {
      console.log('‚ö†Ô∏è Duplicate waitlist signup:', email);
      res.json({
        success: true,
        message: 'You\'re already on our waitlist! We\'ll notify you when Mivton launches.'
      });
    }
    
  } catch (error) {
    console.error('‚ùå Waitlist error:', error);
    res.status(500).json({
      success: false,
      message: 'Something went wrong. Please try again.'
    });
  }
});

app.get('/api/waitlist/stats', async (req, res) => {
  try {
    const stats = await waitlistUtils.getStats();
    res.json({
      success: true,
      data: stats
    });
  } catch (error) {
    console.error('‚ùå Waitlist stats error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get waitlist stats'
    });
  }
});

// Authentication routes
app.use('/api/auth', authRoutes);

// Phase 2.3 Enhanced Routes
try {
  const usersSearchRoutes = require('./routes/users-search');
  const userPreferencesRoutes = require('./routes/user-preferences');
  
  app.use('/api/users', usersSearchRoutes);
  app.use('/api/user', userPreferencesRoutes);
  
  // Create a route alias for languages to be accessible at both locations
  app.get('/api/languages', (req, res) => {
    res.redirect('/api/user/languages');
  });
  
  console.log('‚úÖ Phase 2.3 enhanced routes loaded');
} catch (error) {
  console.log('‚ö†Ô∏è Phase 2.3 routes not available:', error.message);
}

// Phase 3.1 Friends System Routes  
try {
  const friendsRoutes = require('./routes/friends');
  const friendRequestsRoutes = require('./routes/friend-requests');
  const blockedUsersRoutes = require('./routes/blocked-users');
  const socialNotificationsRoutes = require('./routes/social-notifications');
  
  app.use('/api/friends', friendsRoutes);
  app.use('/api/friend-requests', friendRequestsRoutes);
  app.use('/api/blocked-users', blockedUsersRoutes);
  app.use('/api/social-notifications', socialNotificationsRoutes);
  
  console.log('‚úÖ Phase 3.1 friends system routes loaded');
} catch (error) {
  console.log('‚ö†Ô∏è Phase 3.1 routes not available:', error.message);
}

// Phase 3.2 Real-Time API Routes
try {
  const realtimeApiRoutes = require('./routes/realtime-api');
  const notificationsApiRoutes = require('./routes/notifications-api');
  const presenceApiRoutes = require('./routes/presence-api');
  const offlineNotificationsRoutes = require('./routes/offline-notifications');
  const notificationsUnreadRoutes = require('./routes/notifications-unread');
  
  app.use('/api/realtime', realtimeApiRoutes);
  app.use('/api/notifications', notificationsApiRoutes);
  app.use('/api/notifications', offlineNotificationsRoutes); // Offline notifications
  app.use('/api/notifications', notificationsUnreadRoutes); // Unread notifications
  app.use('/api/presence', presenceApiRoutes);
  
  console.log('‚úÖ Phase 3.2 real-time API routes loaded');
} catch (error) {
  console.log('‚ö†Ô∏è Phase 3.2 routes not available:', error.message);
}

// Enhanced Presence Advanced API Routes
try {
  const presenceAdvancedRoutes = require('./routes/presence-advanced');
  app.use('/api/presence/advanced', presenceAdvancedRoutes);
  console.log('‚úÖ Enhanced presence advanced routes loaded');
} catch (error) {
  console.log('‚ö†Ô∏è Enhanced presence advanced routes not available:', error.message);
}

// Phase 3.3 Advanced Social Features Routes
try {
  const friendGroupsRoutes = require('./routes/friend-groups');
  const socialAnalyticsRoutes = require('./routes/social-analytics');
  const friendRecommendationsRoutes = require('./routes/friend-recommendations');
  const privacyControlsRoutes = require('./routes/privacy-controls');
  const conversationPreviewsRoutes = require('./routes/conversation-previews');
  
  app.use('/api/friend-groups', friendGroupsRoutes);
  app.use('/api/social-analytics', socialAnalyticsRoutes);
  app.use('/api/friend-recommendations', friendRecommendationsRoutes);
  app.use('/api/privacy-controls', privacyControlsRoutes);
  app.use('/api/conversation-previews', conversationPreviewsRoutes);
  
  console.log('‚úÖ Phase 3.3 advanced social features routes loaded');
} catch (error) {
  console.log('‚ö†Ô∏è Phase 3.3 routes not available:', error.message);
}

// Chat functionality removed - keeping only friends, auth, and core features

// Chat monitoring removed

// Dashboard routes
const dashboardRoutes = require('./routes/dashboard');
app.use('/api/dashboard', dashboardRoutes);

// Admin routes (admin only)
const adminRoutes = require('./routes/admin');
app.use('/api/admin', adminRoutes);

// Task 4.3: Messages Dev Endpoints
const { saveMessage, getRecentConversation } = require('./database/messages');

// POST /dev/seed-message - Insert a test message
app.post('/dev/seed-message', async (req, res) => {
  try {
    const { senderId = 'test_sender', recipientId = 'test_recipient', body = 'Hello, this is a test message!' } = req.body;
    
    const result = await saveMessage(senderId, recipientId, body);
    
    if (result.success) {
      res.json({
        success: true,
        message: 'Test message inserted successfully',
        data: result.message
      });
    } else {
      res.status(400).json({
        success: false,
        message: 'Failed to insert test message',
        error: result.error
      });
    }
  } catch (error) {
    console.error('‚ùå Dev seed message error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while inserting test message',
      error: error.message
    });
  }
});

// GET /dev/last-messages - Get recent conversation between two users
app.get('/dev/last-messages', async (req, res) => {
  try {
    const { userA, userB, limit = 50 } = req.query;
    
    if (!userA || !userB) {
      return res.status(400).json({
        success: false,
        message: 'Both userA and userB query parameters are required'
      });
    }
    
    const result = await getRecentConversation(userA, userB, parseInt(limit));
    
    if (result.success) {
      res.json({
        success: true,
        data: result
      });
    } else {
      res.status(400).json({
        success: false,
        message: 'Failed to retrieve messages',
        error: result.error
      });
    }
  } catch (error) {
    console.error('‚ùå Dev last messages error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while retrieving messages',
      error: error.message
    });
  }
});

// User Profile routes
const userProfileRoutes = require('./routes/user-profile');
app.use('/api/user-profile', userProfileRoutes);

// Serve login page
app.get('/login', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'login.html'));
});

// Serve registration page
app.get('/register', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'register.html'));
});

// Serve dashboard page
app.get('/dashboard', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'dashboard.html'));
});

// Serve Phase 2.3 demo page
app.get('/demo', (req, res) => {
  res.sendFile(path.join(__dirname, 'demo-phase-2-3.html'));
});

app.get('/demo-phase-2-3.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'demo-phase-2-3.html'));
});

// Serve Enhanced Presence Control demo page
app.get('/demo-presence', (req, res) => {
  res.sendFile(path.join(__dirname, 'demo-enhanced-presence.html'));
});

app.get('/demo-enhanced-presence.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'demo-enhanced-presence.html'));
});

// Serve Task 4.2 test page
app.get('/task-4-2-test', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'task-4-2-test.html'));
});

app.get('/task-4-2-test.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'task-4-2-test.html'));
});

// Test authentication bypass (kept for general testing)
app.post('/api/test/login', async (req, res) => {
  try {
    // Set a test session
    req.session.userId = 'test-user-id';
    req.session.username = 'TestUser';
    req.session.email = 'test@example.com';
    req.session.fullName = 'Test User';
    req.session.isAdmin = false;
    
    res.json({
      success: true,
      message: 'Test login successful',
      user: {
        id: 'test-user-id',
        username: 'TestUser',
        email: 'test@example.com',
        fullName: 'Test User'
      }
    });
  } catch (error) {
    console.error('Test login error:', error);
    res.status(500).json({ error: 'Test login failed' });
  }
});

// Chat functionality removed - continuing with server setup

// All chat endpoints removed - continuing with error handling
app.get('/api/direct-chat/conversation/:userId', async (req, res) => {
  const { userId } = req.params;
  const currentUserId = req.query.userId || 'user-' + Date.now();
  
  console.log(`üì® FINAL WORKING CHAT conversation: ${currentUserId} <-> ${userId}`);
  
  try {
    // Try to get messages from database first - convert IDs to strings
    const db = require('./database/connection');
    const result = await db.query(`
      SELECT id, sender_id, recipient_id, body, created_at
      FROM messages 
      WHERE (sender_id = $1 AND recipient_id = $2) OR (sender_id = $2 AND recipient_id = $1)
      ORDER BY created_at ASC
    `, [String(currentUserId), String(userId)]);
    
    const dbMessages = result.rows.map(msg => ({
      id: msg.id,
      sender_id: msg.sender_id,
      recipient_id: msg.recipient_id,
      body: msg.body,
      created_at: msg.created_at,
      is_sender: msg.sender_id === currentUserId,
      sender_name: msg.sender_id === currentUserId ? 'You' : 'Friend'
    }));
    
    console.log(`üìö Loaded ${dbMessages.length} messages from database`);
    
    res.json({
      success: true,
      conversation: dbMessages,
      friend: {
        id: userId,
        fullName: 'Silviu Timaru',
        username: 'silviu',
        status: 'online'
      },
      count: dbMessages.length
    });
    
  } catch (error) {
    console.error('‚ùå Error loading messages from database:', error);
    
    // Fallback to memory storage
    const conversationMessages = workingMessages.filter(msg => 
      (msg.senderId === currentUserId && msg.recipientId === userId) ||
      (msg.senderId === userId && msg.recipientId === currentUserId)
    );
    
    res.json({
      success: true,
      conversation: conversationMessages.map(msg => ({
        id: msg.id,
        sender_id: msg.senderId,
        recipient_id: msg.recipientId,
        body: msg.body,
        created_at: msg.timestamp,
        is_sender: msg.senderId === currentUserId,
        sender_name: msg.senderId === currentUserId ? 'You' : 'Friend'
      })),
      friend: {
        id: userId,
        fullName: 'Silviu Timaru',
        username: 'silviu',
        status: 'online'
      },
      count: conversationMessages.length
    });
  }
});

app.post('/api/direct-chat/send', async (req, res) => {
  const { recipientId, message, userId } = req.body;
  const senderId = userId || 'user-' + Date.now();
  
  if (!recipientId || !message) {
    return res.status(400).json({
      success: false,
      error: 'Recipient ID and message are required'
    });
  }
  
  console.log(`üí¨ FINAL WORKING CHAT send: ${senderId} -> ${recipientId}: ${message}`);
  
  try {
    // Save to database - convert all IDs to strings to match TEXT columns
    const db = require('./database/connection');
    
    // Check if multilingual columns exist, if not add them
    await ensureMultilingualColumns(db);
    
    const result = await db.query(`
      INSERT INTO messages (sender_id, recipient_id, body, original_text, translated_text, original_lang, translated_lang, created_at)
      VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
      RETURNING id, sender_id, recipient_id, body, created_at
    `, [
      String(senderId),
      String(recipientId), 
      message.trim(),
      message.trim(),
      message.trim(),
      'en',
      'en'
    ]);
    
    const savedMessage = result.rows[0];
    
    // Also store in memory for immediate access
    const newMessage = {
      id: savedMessage.id,
      senderId: savedMessage.sender_id,
      recipientId: savedMessage.recipient_id,
      body: savedMessage.body,
      timestamp: savedMessage.created_at
    };
    
    workingMessages.push(newMessage);
    
    // üî• REAL-TIME NOTIFICATION: Notify the recipient via Socket.IO
    console.log(`üì° Sending real-time notification to recipient: ${recipientId}`);
    io.to(`user-${recipientId}`).emit('new_message', {
      message: newMessage,
      sender: {
        id: senderId,
        fullName: 'You',
        username: 'user',
        status: 'online'
      }
    });
    
    // Also notify in a general chat room
    io.emit('chat_message', {
      message: newMessage,
      sender: senderId,
      recipient: recipientId
    });
    
    res.json({
      success: true,
      message: {
        id: newMessage.id,
        senderId: newMessage.senderId,
        recipientId: newMessage.recipientId,
        body: newMessage.body,
        createdAt: newMessage.timestamp,
        sender: {
          id: senderId,
          fullName: 'You',
          username: 'user',
          status: 'online'
        }
      }
    });
    
  } catch (error) {
    console.error('‚ùå Error saving message to database:', error);
    
    // üî• AUTO-FIX: If it's a database schema error, try to fix it
    if (error.message.includes('operator does not exist: integer = text')) {
      console.log('üîß Auto-fixing database schema error...');
      try {
        // Fix the database schema
        await db.query('ALTER TABLE messages ALTER COLUMN sender_id TYPE TEXT;');
        await db.query('ALTER TABLE messages ALTER COLUMN recipient_id TYPE TEXT;');
        
        // Fix the trigger function
        await db.query(`
          CREATE OR REPLACE FUNCTION update_conversation_timestamp()
          RETURNS TRIGGER AS $$
          BEGIN
              UPDATE conversations 
              SET updated_at = CURRENT_TIMESTAMP
              WHERE id IN (
                  SELECT id FROM conversations 
                  WHERE (user_a = NEW.sender_id::TEXT AND user_b = NEW.recipient_id::TEXT)
                     OR (user_a = NEW.recipient_id::TEXT AND user_b = NEW.sender_id::TEXT)
              );
              RETURN NEW;
          END;
          $$ LANGUAGE plpgsql;
        `);
        
        console.log('‚úÖ Database schema auto-fixed, retrying message save...');
        
        // Retry saving the message
        const retryResult = await db.query(`
          INSERT INTO messages (sender_id, recipient_id, body, original_text, translated_text, original_lang, translated_lang, created_at)
          VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
          RETURNING id, sender_id, recipient_id, body, created_at
        `, [
          String(senderId),
          String(recipientId), 
          message.trim(),
          message.trim(),
          message.trim(),
          'en',
          'en'
        ]);
        
        const retryMessage = retryResult.rows[0];
        
        // Also store in memory for immediate access
        const newMessage = {
          id: retryMessage.id,
          senderId: retryMessage.sender_id,
          recipientId: retryMessage.recipient_id,
          body: retryMessage.body,
          timestamp: retryMessage.created_at
        };
        
        workingMessages.push(newMessage);
        
        // üî• REAL-TIME NOTIFICATION
        console.log(`üì° Sending real-time notification to recipient: ${recipientId}`);
        io.to(`user-${recipientId}`).emit('new_message', {
          message: newMessage,
          sender: {
            id: senderId,
            fullName: 'You',
            username: 'user',
            status: 'online'
          }
        });
        
        io.emit('chat_message', {
          message: newMessage,
          sender: senderId,
          recipient: recipientId
        });
        
        res.json({
          success: true,
          message: {
            id: newMessage.id,
            senderId: newMessage.senderId,
            recipientId: newMessage.recipientId,
            body: newMessage.body,
            createdAt: newMessage.timestamp,
            sender: {
              id: senderId,
              fullName: 'You',
              username: 'user',
              status: 'online'
            }
          }
        });
        
        return; // Exit early on successful retry
        
      } catch (fixError) {
        console.error('‚ùå Auto-fix failed:', fixError);
      }
    }
    
    // Fallback to memory storage
    const newMessage = {
      id: workingMessageId++,
      senderId: senderId,
      recipientId: recipientId,
      body: message.trim(),
      timestamp: new Date().toISOString()
    };
    
    workingMessages.push(newMessage);
    
    // üî• REAL-TIME NOTIFICATION: Even for fallback messages
    console.log(`üì° Sending real-time notification to recipient (fallback): ${recipientId}`);
    io.to(`user-${recipientId}`).emit('new_message', {
      message: newMessage,
      sender: {
        id: senderId,
        fullName: 'You',
        username: 'user',
        status: 'online'
      }
    });
    
    // Also notify in a general chat room
    io.emit('chat_message', {
      message: newMessage,
      sender: senderId,
      recipient: recipientId
    });
    
    res.json({
      success: true,
      message: {
        id: newMessage.id,
        senderId: newMessage.senderId,
        recipientId: newMessage.recipientId,
        body: newMessage.body,
        createdAt: newMessage.timestamp,
        sender: {
          id: senderId,
          fullName: 'You',
          username: 'user',
          status: 'online'
        }
      }
    });
  }
});

// FIXED: Add conversations endpoint directly
app.get('/api/direct-chat/conversations', (req, res) => {
  try {
    console.log('üì¨ Conversations endpoint called');
    
    const currentUserId = req.query.userId || 'default-user';
    
    console.log('üì¨ Current user ID:', currentUserId);
    
    // Get unique conversation partners from workingMessages
    const partners = new Set();
    workingMessages.forEach(msg => {
      if (msg.senderId === currentUserId) {
        partners.add(msg.recipientId);
      } else if (msg.recipientId === currentUserId) {
        partners.add(msg.senderId);
      }
    });

    const conversationList = Array.from(partners).map(partnerId => {
      // Get last message for this partner
      const lastMessage = workingMessages
        .filter(msg => 
          (msg.senderId === currentUserId && msg.recipientId === partnerId) ||
          (msg.senderId === partnerId && msg.recipientId === currentUserId)
        )
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];
      
      return {
        conversation_id: [currentUserId, partnerId].sort().join('-'),
        friend_id: partnerId,
        friend_name: 'Silviu Timaru',
        last_message_body: lastMessage?.body || 'No messages yet',
        last_message_at: lastMessage?.timestamp || new Date().toISOString(),
        unread_count: 0
      };
    });

    res.json({
      success: true,
      conversations: conversationList,
      message: 'Conversations endpoint working',
      userId: currentUserId
    });

  } catch (error) {
    console.error('‚ùå Error getting conversations:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

// Test endpoint to verify route registration
app.get('/api/chat/test-simple', (req, res) => {
  res.json({ success: true, message: 'Simple test endpoint working!' });
});


// Test multilingual chat system
app.get('/api/chat/test-multilingual', async (req, res) => {
  try {
    console.log('üß™ Testing multilingual chat system...');
    
    const results = {
      routes: 'Unknown',
      translation: 'Unknown',
      messages: 'Unknown',
      socket: 'Unknown',
      database: 'Unknown'
    };
    
    // Test routes
    try {
      const routes = require('./routes/multilingual-chat');
      results.routes = 'Working';
    } catch (error) {
      results.routes = 'Failed: ' + error.message;
    }
    
    // Test translation service
    try {
      const translationService = require('./services/openai-translation');
      results.translation = translationService.isAvailable() ? 'Working (API Key: ' + (process.env.OPENAI_API_KEY ? 'Set' : 'Missing') + ')' : 'Working (No API Key)';
    } catch (error) {
      results.translation = 'Failed: ' + error.message;
    }
    
    // Test messages service
    try {
      const messagesService = require('./services/multilingual-messages');
      results.messages = 'Working';
    } catch (error) {
      results.messages = 'Failed: ' + error.message;
    }
    
    // Test socket events
    try {
      const socketEvents = require('./socket/multilingual-chat-events');
      results.socket = 'Working';
    } catch (error) {
      results.socket = 'Failed: ' + error.message;
    }
    
    // Test database
    try {
      const db = getDb();
      
      // Check if multilingual columns exist
      const columnsResult = await db.query(`
        SELECT column_name 
        FROM information_schema.columns 
        WHERE table_name = 'messages' 
        AND column_name IN ('original_text', 'translated_text', 'original_lang', 'translated_lang')
      `);
      
      results.database = columnsResult.rows.length === 4 ? 'Working (All columns exist)' : `Partial (${columnsResult.rows.length}/4 columns)`;
      
    } catch (error) {
      results.database = 'Failed: ' + error.message;
    }
    
    res.json({
      success: true,
      timestamp: new Date().toISOString(),
      message: 'Multilingual chat system test completed',
      results: results,
      recommendations: [
        results.routes.includes('Failed') ? 'Fix route loading in server.js' : null,
        results.translation.includes('Missing') ? 'Set OPENAI_API_KEY environment variable' : null,
        results.database.includes('Failed') || results.database.includes('Partial') ? 'Run database migration' : null,
        results.socket.includes('Failed') ? 'Check Socket.IO events initialization' : null
      ].filter(Boolean)
    });
    
  } catch (error) {
    console.error('‚ùå Test endpoint error:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      message: 'Test failed - check server logs'
    });
  }
});

// Simple chat test endpoint (no auth required)
app.post('/api/chat/test-send', async (req, res) => {
  try {
    const { message, fromLang = 'en', toLang = 'ro' } = req.body;
    
    if (!message) {
      return res.status(400).json({
        success: false,
        error: 'Message is required'
      });
    }
    
    console.log('üß™ Testing message send:', message);
    
    // Try to use translation service
    let translationResult = null;
    try {
      const translationService = require('./services/openai-translation');
      if (translationService.isAvailable()) {
        translationResult = await translationService.translateText(message, fromLang, toLang);
      } else {
        translationResult = {
          success: false,
          error: 'OpenAI API key not configured',
          translatedText: message // Fallback to original
        };
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Translation failed:', error.message);
      translationResult = {
        success: false,
        error: error.message,
        translatedText: message // Fallback
      };
    }
    
    // Try to save to database
    let dbResult = null;
    try {
      const messagesService = require('./services/multilingual-messages');
      dbResult = await messagesService.saveMultilingualMessage(
        'test-user-1',
        'test-user-2', 
        message,
        fromLang
      );
    } catch (error) {
      console.log('‚ö†Ô∏è Database save failed:', error.message);
      dbResult = {
        success: false,
        error: error.message
      };
    }
    
    res.json({
      success: true,
      message: 'Test completed',
      originalMessage: message,
      translation: translationResult,
      database: dbResult,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Chat test error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Serve Presence Settings page
app.get('/presence-settings', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'presence-settings.html'));
});

// Redirect root to appropriate page based on authentication
app.get('/', (req, res) => {
  if (req.session && req.session.userId) {
    res.redirect('/dashboard.html');
  } else {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
  }
});

// ===== SOCKET.IO SETUP =====

// Initialize Complete Chat System and Enhanced Real-Time Events
try {
  const { initializeEnhancedFriendsEvents } = require('./socket/enhanced-friends-events');
  const { initializeCompleteChatEvents } = require('./socket/complete-chat-events');
  
  initializeEnhancedFriendsEvents(io);
  initializeCompleteChatEvents(io);
  
  console.log('‚úÖ Enhanced real-time events loaded (chat removed)');
  
  // Store io instance globally for access from other modules
  global.io = io;
  
} catch (error) {
  console.log('‚ö†Ô∏è Enhanced real-time events not available, falling back to Phase 3.1:', error.message);
  
  try {
    const { initializeFriendsEvents } = require('./socket/friends-events');
    initializeFriendsEvents(io);
    console.log('‚úÖ Phase 3.1 Friends Socket.IO events loaded (fallback)');
  } catch (fallbackError) {
    console.log('‚ö†Ô∏è Friends Socket.IO events not available:', fallbackError.message);
    
    // üî• FIXED: Proper Socket.IO authentication with session cookies
    io.use((socket, next) => {
      try {
        // Extract session cookie from handshake
        const cookies = socket.handshake.headers.cookie;
        console.log('üç™ Cookies received:', cookies);
        
        if (cookies) {
          // Parse session ID from cookie (same pattern as in server.js)
          const sessionMatch = cookies.match(/mivton\.sid=s%3A([^;]+)/);
          if (sessionMatch) {
            const sessionId = sessionMatch[1];
            console.log('üîç Extracted session ID using pattern: /mivton\\.sid=s%3A([^;]+)/');
            console.log('üç™ Found session:', sessionId.substring(0, 20) + '...');
            
            // Store session ID on socket for later use
            socket.sessionId = sessionId;
            next();
            return;
          }
        }
        
        console.log('üîç No valid session found for:', socket.id);
        // Allow connection but mark as anonymous
        socket.isAnonymous = true;
        next();
      } catch (error) {
        console.error('‚ùå Socket auth error:', error);
        socket.isAnonymous = true;
        next();
      }
    });
    
    io.on('connection', (socket) => {
      if (socket.isAnonymous) {
        console.log(`üîì Socket connected without authentication: ${socket.id}`);
      } else {
        console.log(`üîê Socket connected with session: ${socket.id}`);
      }
      
      // Task 4.2: Room management
      socket.on('join', (userIdForRoom) => {
        try {
          const roomName = `user-${userIdForRoom}`; // üî• FIXED: Match the format used in chat notifications
          socket.join(roomName);
          console.log(`üöÄ Socket ${socket.id} joined room: ${roomName}`);
          
          // Store the room info on the socket for cleanup
          socket.userRoom = roomName;
          socket.roomUserId = userIdForRoom;
          
          // Send confirmation
          socket.emit('joined', { room: roomName, userId: userIdForRoom });
        } catch (error) {
          console.error('‚ùå Error joining room:', error);
        }
      });

      socket.on('server:notify', (data) => {
        try {
          const { to, msg } = data;
          console.log(`üöÄ Notify request from ${socket.id}: ${to} -> ${msg}`);
          
          // Send notification to the target room
          io.to(to).emit('notify', { msg });
          console.log(`‚úâÔ∏è Sent notify to room ${to}: ${msg}`);
        } catch (error) {
          console.error('‚ùå Error sending notify:', error);
        }
      });
      
      // Task 4.1: Basic ping-pong functionality
      socket.on('ping', (data) => {
        console.log(`üèì Ping received from ${socket.id}:`, data);
        socket.emit('pong', {
          timestamp: data.timestamp,
          serverTime: Date.now(),
          message: 'pong'
        });
      });
      
      socket.on('disconnect', () => {
        console.log(`üî¥ Socket disconnected: ${socket.id}`);
        
        // Task 4.2: Clean up room membership
        if (socket.userRoom) {
          socket.leave(socket.userRoom);
          console.log(`üöä Socket ${socket.id} left room: ${socket.userRoom}`);
        }
      });
      
      socket.on('message', (data) => {
        console.log(`üí¨ Message from ${socket.id}: ${data}`);
      });
    });
  }
}

// ===== TEMPORARY ADMIN ENDPOINT =====

// Temporary admin endpoint to make silviu@mivton.com an admin
app.get('/temp-admin-fix', async (req, res) => {
    try {
        console.log('üëë Temporary admin fix - making silviu@mivton.com an admin...');
        
        const db = getDb();
        
        // Update user to admin
        const updateResult = await db.query(
            'UPDATE users SET is_admin = true, admin_level = 3, updated_at = CURRENT_TIMESTAMP WHERE email = $1 RETURNING *',
            ['silviu@mivton.com']
        );
        
        if (updateResult.rows.length > 0) {
            const updatedUser = updateResult.rows[0];
            console.log('‚úÖ User successfully updated to admin:', updatedUser);
            res.json({
                success: true,
                message: 'User updated to admin successfully',
                user: updatedUser
            });
        } else {
            res.json({
                success: false,
                message: 'User not found'
            });
        }
        
    } catch (error) {
        console.error('‚ùå Error making user admin:', error);
        res.status(500).json({
            success: false,
            message: 'Error updating user',
            error: error.message
        });
    }
});

// Temporary password update endpoint
app.get('/temp-password-fix', async (req, res) => {
    try {
        console.log('üîê Updating password for silviu@mivton.com to Bacau@2012...');
        
        const db = getDb();
        const bcrypt = require('bcrypt');
        const newPassword = 'Bacau@2012';
        
        // Generate new password hash
        const saltRounds = 10;
        const newPasswordHash = await bcrypt.hash(newPassword, saltRounds);
        
        // Update password in database
        const updateResult = await db.query(
            'UPDATE users SET password_hash = $1, updated_at = CURRENT_TIMESTAMP WHERE email = $2 RETURNING *',
            [newPasswordHash, 'silviu@mivton.com']
        );
        
        if (updateResult.rows.length > 0) {
            const updatedUser = updateResult.rows[0];
            console.log('‚úÖ Password successfully updated for user:', updatedUser.email);
            res.json({
                success: true,
                message: 'Password updated successfully',
                user: {
                    id: updatedUser.id,
                    username: updatedUser.username,
                    email: updatedUser.email,
                    is_admin: updatedUser.is_admin,
                    admin_level: updatedUser.admin_level,
                    updated_at: updatedUser.updated_at
                },
                newPassword: newPassword
            });
        } else {
            res.json({
                success: false,
                message: 'User not found'
            });
        }
        
    } catch (error) {
        console.error('‚ùå Error updating password:', error);
        res.status(500).json({
            success: false,
            message: 'Error updating password',
            error: error.message
        });
    }
});

// ===== ERROR HANDLING =====

// 404 handler
app.use((req, res) => {
  res.status(404).json({
    error: 'Not Found',
    message: 'The requested resource was not found',
    timestamp: new Date().toISOString()
  });
});

// Global error handler
app.use((err, req, res, next) => {
  console.error('Global error handler:', err);
  
  res.status(err.status || 500).json({
    error: process.env.NODE_ENV === 'production' ? 'Internal Server Error' : err.message,
    timestamp: new Date().toISOString()
  });
});

// ===== SERVER STARTUP =====

const startServer = async () => {
  try {
    console.log('üöÄ Starting Mivton server...');
    
    // Initialize database (non-blocking)
    console.log('üìä Initializing database connection...');
    try {
      await initializeDatabase();
      console.log('‚úÖ Database connected successfully');
    } catch (dbError) {
      console.log('‚ö†Ô∏è Database connection failed, but server will continue:', dbError.message);
      console.log('‚ÑπÔ∏è Some features may not work, but basic functionality is available');
    }
    
    // Run complete chat system migration
    try {
      const { runCompleteChatMigration } = require('./run-complete-chat-migration.js');
      await runCompleteChatMigration();
    } catch (migrationError) {
      console.log('‚ö†Ô∏è Complete chat system migration failed, but continuing:', migrationError.message);
    }
    
    // Initialize Phase 3.1 Friends Database Schema
    try {
      const { initializeFriendsSchema, isSchemaInitialized } = require('./database/init-friends');
      
      const schemaExists = await isSchemaInitialized();
      if (!schemaExists) {
        console.log('üîÑ Initializing friends database schema...');
        await initializeFriendsSchema();
        console.log('‚úÖ Friends database schema initialized');
      } else {
        console.log('‚úÖ Friends database schema already exists');
      }
    } catch (friendsError) {
      console.log('‚ö†Ô∏è Friends schema initialization failed, but continuing:', friendsError.message);
    }
    
    // Initialize Phase 3.2 Real-Time Database Schema
    try {
      const { initializeRealtimeSchema, isRealtimeSchemaInitialized } = require('./database/init-realtime');
      
      const realtimeSchemaExists = await isRealtimeSchemaInitialized();
      if (!realtimeSchemaExists) {
        console.log('üîÑ Initializing real-time database schema...');
        const schemaInitialized = await initializeRealtimeSchema();
        if (schemaInitialized) {
          console.log('‚úÖ Real-time database schema initialized');
        } else {
          console.log('‚ùå Real-time schema initialization failed - some features may not work');
        }
      } else {
        console.log('‚úÖ Real-time database schema already exists');
      }
    } catch (realtimeError) {
      console.log('‚ö†Ô∏è Real-time schema initialization failed, but continuing:', realtimeError.message);
      console.log('‚ÑπÔ∏è Run "railway run npm run init:realtime" to fix this manually');
    }
    
    // Initialize Phase 3.3 Advanced Social Features Database Schema
    try {
      const { initializeAdvancedSocial, isAdvancedSocialSchemaInitialized } = require('./database/init-advanced-social');
      
      const advancedSocialExists = await isAdvancedSocialSchemaInitialized();
      if (!advancedSocialExists) {
        console.log('üîÑ Initializing advanced social features database schema...');
        const schemaInitialized = await initializeAdvancedSocial();
        if (schemaInitialized) {
          console.log('‚úÖ Advanced social features database schema initialized');
        } else {
          console.log('‚ùå Advanced social schema initialization failed - Phase 3.3 features may not work');
        }
      } else {
        console.log('‚úÖ Advanced social features database schema already exists');
      }
    } catch (advancedSocialError) {
      console.log('‚ö†Ô∏è Advanced social schema initialization failed, but continuing:', advancedSocialError.message);
      console.log('‚ÑπÔ∏è Run "railway run npm run init:advanced-social" to fix this manually');
    }
    
    // Initialize Advanced Presence Schema
    try {
    const { initializeAdvancedPresenceSchema, isAdvancedPresenceSchemaInitialized } = require('./database/init-advanced-presence');
    
    const advancedPresenceExists = await isAdvancedPresenceSchemaInitialized();
    if (!advancedPresenceExists) {
    console.log('üîÑ Initializing advanced presence database schema...');
    const schemaInitialized = await initializeAdvancedPresenceSchema();
    if (schemaInitialized) {
    console.log('‚úÖ Advanced presence database schema initialized');
    } else {
    console.log('‚ùå Advanced presence schema initialization failed - presence features may not work');
    }
    } else {
    console.log('‚úÖ Advanced presence database schema already exists');
    }
    } catch (advancedPresenceError) {
    console.log('‚ö†Ô∏è Advanced presence schema initialization failed, but continuing:', advancedPresenceError.message);
    }
    
    // Auto-fix socket_sessions schema (critical for real-time features)
    try {
        const { autoFixSocketSessionsSchema } = require('./database/auto-fix-socket-schema');
        await autoFixSocketSessionsSchema();
    } catch (socketSchemaError) {
        console.log('‚ö†Ô∏è Socket sessions schema auto-fix failed:', socketSchemaError.message);
    }
    
  } catch (error) {
    console.error('‚ùå Database initialization failed:', error);
    console.log('üîÑ Continuing with server startup anyway...');
  }
  
  // Start the server regardless of database status
  server.listen(PORT, HOST, () => {
      console.log('');
      console.log('üéâ Mivton server is running!');
      console.log(`üåê URL: ${process.env.APP_URL || `http://localhost:${PORT}`}`);
      console.log(`üîß Environment: ${process.env.NODE_ENV || 'development'}`);
      console.log(`üìä Phase: 3.3 - Advanced Social Features ACTIVE`);
      console.log(`üöÄ Server ready to accept requests - App is accessible immediately!`);
      console.log('');
      console.log('‚úÖ Features enabled:');
      console.log('   - Landing page');
      console.log('   - User registration & login');
      console.log('   - Password security (bcrypt)');
      console.log('   - Session management');
      console.log('   - Email integration (Hostinger)');
      console.log('   - Database storage');
      console.log('   - Waitlist system');
      console.log('   - Health monitoring');
      console.log('   - Socket.IO with real-time friends events');
      console.log('   - Dashboard with navigation');
      console.log('   - Profile management');
      console.log('   - User search functionality');
      console.log('   - Enhanced profile cards');
      console.log('   - Status manager');
      console.log('   - Settings interface');
      console.log('   - Phase 2.3 UI Polish components');
      console.log('   - Phase 3.1 Friends System');
      console.log('   - Friend requests management');
      console.log('   - User blocking system');
      console.log('   - Social notifications');
      console.log('   - Phase 3.2 Real-Time Social Updates');
      console.log('   - Real-time presence management');
      console.log('   - Live notification delivery');
      console.log('   - Friend activity feed');
      console.log('   - Socket connection management');
      console.log('   - Advanced notification system');
      console.log('   - Phase 3.3 Advanced Social Features (NEW)');
      console.log('   - Friend groups and organization');
      console.log('   - Social analytics and insights');
      console.log('   - AI-powered friend recommendations');
      console.log('   - Advanced privacy controls');
      console.log('   - Conversation previews and management');
      console.log('   - Social interaction tracking');
      console.log('');
      console.log('üìã Available endpoints:');
      console.log('   ‚Ä¢ GET  /health - Health check');
      console.log('   ‚Ä¢ GET  /api/status - API status');
      console.log('   ‚Ä¢ POST /api/auth/register - User registration');
      console.log('   ‚Ä¢ POST /api/auth/login - User login');
      console.log('   ‚Ä¢ POST /api/auth/logout - User logout');
      console.log('   ‚Ä¢ GET  /api/auth/me - Current user data');
      console.log('   ‚Ä¢ GET  /api/auth/status - Auth status');
      console.log('   ‚Ä¢ GET  /api/auth/check-username/:username - Username availability');
      console.log('   ‚Ä¢ GET  /api/auth/check-email/:email - Email availability');
      console.log('   ‚Ä¢ POST /api/waitlist - Waitlist signup');
      console.log('   ‚Ä¢ GET  /api/waitlist/stats - Waitlist statistics');
      console.log('   ‚Ä¢ GET  /api/dashboard/stats - Dashboard statistics');
      console.log('   ‚Ä¢ PUT  /api/dashboard/profile - Update profile');
      console.log('   ‚Ä¢ GET  /api/dashboard/search-users - Search users');
      console.log('   ‚Ä¢ GET  /api/users/search - Enhanced user search (Phase 2.3)');
      console.log('   ‚Ä¢ GET  /api/users/profiles - Profile cards data (Phase 2.3)');
      console.log('   ‚Ä¢ GET  /api/user/preferences - User preferences (Phase 2.3)');
      console.log('   ‚Ä¢ PUT  /api/user/preferences - Update preferences (Phase 2.3)');
      console.log('   ‚Ä¢ PUT  /api/user/status - Update user status (Phase 2.3)');
      console.log('   ‚Ä¢ GET  /api/friends - Get friends list (Phase 3.1)');
      console.log('   ‚Ä¢ DELETE /api/friends/:id - Remove friend (Phase 3.1)');
      console.log('   ‚Ä¢ POST /api/friend-requests - Send friend request (Phase 3.1)');
      console.log('   ‚Ä¢ PUT  /api/friend-requests/:id/accept - Accept request (Phase 3.1)');
      console.log('   ‚Ä¢ PUT  /api/friend-requests/:id/decline - Decline request (Phase 3.1)');
      console.log('   ‚Ä¢ GET  /api/friend-requests/received - Received requests (Phase 3.1)');
      console.log('   ‚Ä¢ GET  /api/friend-requests/sent - Sent requests (Phase 3.1)');
      console.log('   ‚Ä¢ POST /api/blocked-users - Block user (Phase 3.1)');
      console.log('   ‚Ä¢ DELETE /api/blocked-users/:id - Unblock user (Phase 3.1)');
      console.log('   ‚Ä¢ GET  /api/social-notifications - Get notifications (Phase 3.1)');
      console.log('   ‚Ä¢ GET  /api/realtime/stats - Real-time statistics (Phase 3.2)');
      console.log('   ‚Ä¢ GET  /api/notifications - Enhanced notifications API (Phase 3.2)');
      console.log('   ‚Ä¢ GET  /api/presence/friends - Friends presence status (Phase 3.2)');
      console.log('   ‚Ä¢ PUT  /api/presence/status - Update presence status (Phase 3.2)');
      console.log('   ‚Ä¢ GET  /api/realtime/activity/feed - Activity feed (Phase 3.2)');
      console.log('   ‚Ä¢ POST /dev/seed-message - Insert test message (Task 4.3 dev)');
      console.log('   ‚Ä¢ GET  /dev/last-messages?userA=a&userB=b - Get conversation (Task 4.3 dev)');
      console.log('');
      console.log('üì± Pages available:');
      console.log('   ‚Ä¢ GET  / - Landing page (redirects based on auth)');
      console.log('   ‚Ä¢ GET  /login.html - Login page');
      console.log('   ‚Ä¢ GET  /register.html - Registration page');
      console.log('   ‚Ä¢ GET  /dashboard.html - User dashboard');
      console.log('   ‚Ä¢ GET  /demo - Phase 2.3 UI Components Demo');
      console.log('');
      
      // Run slow operations in background after server starts
      setImmediate(async () => {
        // Test email connection in background (non-blocking)
        console.log('üìß Testing email configuration in background...');
        try {
          await testEmailConnection();
          console.log('‚úÖ Email connection successful');
        } catch (emailError) {
          console.log('‚ö†Ô∏è Email connection failed, but continuing:', emailError.message);
        }
      });
    });
};

// Graceful shutdown handling
process.on('SIGTERM', () => {
  console.log('üõë SIGTERM received, shutting down gracefully...');
  server.close(() => {
    console.log('‚úÖ Server closed successfully');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('üõë SIGINT received, shutting down gracefully...');
  server.close(() => {
    console.log('‚úÖ Server closed successfully');
    process.exit(0);
  });
});

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught Exception:', error);
  // Don't exit, just log the error
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Unhandled Rejection at:', promise, 'reason:', reason);
  // Don't exit, just log the error
});

// Register non-chat user API routes
const registerUserRoutes = () => {
  try {
    const userApiRoutes = require('./routes/user-api');
    app.use('/api/user', userApiRoutes);
    console.log('‚úÖ User API routes loaded (chat functionality removed)');
  } catch (error) {
    console.log('‚ö†Ô∏è User API routes not available:', error.message);
  }
};

// Start the server with error handling
startServer().then(() => {
  console.log('üîß DEBUG: Server started, registering user routes...');
  registerUserRoutes();
}).catch((error) => {
  console.error('‚ùå Failed to start server:', error);
  // Don't exit immediately, try to restart
  setTimeout(() => {
    console.log('üîÑ Attempting to restart server...');
    startServer();
  }, 5000);
});
